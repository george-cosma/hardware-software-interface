"use strict";(self.webpackChunkhardware_software_interface=self.webpackChunkhardware_software_interface||[]).push([[320],{5680:(e,t,a)=>{a.d(t,{xA:()=>g,yg:()=>c});var n=a(6540);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},g=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},y=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,g=l(e,["components","mdxType","originalType","parentName"]),m=p(a),y=r,c=m["".concat(s,".").concat(y)]||m[y]||d[y]||i;return a?n.createElement(c,o(o({ref:t},g),{},{components:a})):n.createElement(c,o({ref:t},g))}));function c(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=y;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}y.displayName="MDXCreateElement"},7615:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var n=a(8168),r=(a(6540),a(5680));const i={},o="Binary and Hexadecimal Systems",l={unversionedId:"Lab 1 - Number Representation/Binary and Hexadecimal/Reading/README",id:"Lab 1 - Number Representation/Binary and Hexadecimal/Reading/README",title:"Binary and Hexadecimal Systems",description:"For representing information (instructions and data), computers use the binary system (base 2).",source:"@site/docs/Lab 1 - Number Representation/Binary and Hexadecimal/Reading/README.md",sourceDirName:"Lab 1 - Number Representation/Binary and Hexadecimal/Reading",slug:"/Lab 1 - Number Representation/Binary and Hexadecimal/Reading/",permalink:"/hardware-software-interface/Lab 1 - Number Representation/Binary and Hexadecimal/Reading/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Binary and Hexadecimal",permalink:"/hardware-software-interface/Lab 1 - Number Representation/Binary and Hexadecimal/"},next:{title:"Drills",permalink:"/hardware-software-interface/Lab 1 - Number Representation/Binary and Hexadecimal/Drills/"}},s={},p=[{value:"Binary System",id:"binary-system",level:2},{value:"Operations with Values Represented in Binary",id:"operations-with-values-represented-in-binary",level:3},{value:"Arithmetic Operations",id:"arithmetic-operations",level:4},{value:"Logical Operations",id:"logical-operations",level:3},{value:"Operators on Binary Values",id:"operators-on-binary-values",level:4},{value:"Logical Shifts",id:"logical-shifts",level:4},{value:"Hexadecimal System",id:"hexadecimal-system",level:2},{value:"Conversion from Decimal to Binary/Hexadecimal",id:"conversion-from-decimal-to-binaryhexadecimal",level:3},{value:"Example: Conversion of the number 0xD9B1 to decimal",id:"example-conversion-of-the-number-0xd9b1-to-decimal",level:4},{value:"Conversion between Binary and Hexadecimal",id:"conversion-between-binary-and-hexadecimal",level:3},{value:"Example: Conversion of the number 0xD9B1 to binary",id:"example-conversion-of-the-number-0xd9b1-to-binary",level:4},{value:"Use of Base 16 Representation",id:"use-of-base-16-representation",level:3},{value:"Representation of Data Types",id:"representation-of-data-types",level:2},{value:"Order of Representation for Numbers Larger than One Byte (Little-Endian vs Big-Endian)",id:"order-of-representation-for-numbers-larger-than-one-byte-little-endian-vs-big-endian",level:2}],g={toc:p},m="wrapper";function d(e){let{components:t,...i}=e;return(0,r.yg)(m,(0,n.A)({},g,i,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"binary-and-hexadecimal-systems"},"Binary and Hexadecimal Systems"),(0,r.yg)("p",null,"For representing information (instructions and data), computers use the binary system (base 2).\nWhen writing programs in assembly language, the hexadecimal system (base 16) is preferred because it saves the programmer from writing long strings of 1s and 0s, and conversion to/from binary can be done much more easily than with the decimal system (base 10)."),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"NOTE"),": We'll use the prefix ",(0,r.yg)("inlineCode",{parentName:"p"},"0b")," for representing numbers in binary and ",(0,r.yg)("inlineCode",{parentName:"p"},"0x")," for hexadecimal numbers.\nFor example, we can write the unsigned integer ",(0,r.yg)("inlineCode",{parentName:"p"},"127")," as ",(0,r.yg)("inlineCode",{parentName:"p"},"0b01111111")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"0x7F"),".")),(0,r.yg)("h2",{id:"binary-system"},"Binary System"),(0,r.yg)("p",null,"In the ",(0,r.yg)("strong",{parentName:"p"},"binary system")," (base 2), values are represented as a string of 0s and 1s.\nEach digit in the string represents a bit, and a group of 8 bits forms a byte.\nA group of 4 bits is called a ",(0,r.yg)("strong",{parentName:"p"},"nibble")," or ",(0,r.yg)("strong",{parentName:"p"},"half-byte"),"."),(0,r.yg)("h3",{id:"operations-with-values-represented-in-binary"},"Operations with Values Represented in Binary"),(0,r.yg)("h4",{id:"arithmetic-operations"},"Arithmetic Operations"),(0,r.yg)("p",null,"Arithmetic operations are the classic ",(0,r.yg)("inlineCode",{parentName:"p"},"+"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"-"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"*"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"/")," (integer division), ",(0,r.yg)("inlineCode",{parentName:"p"},"%")," (modulo).\nFundamentally they work the same way in any base 10, 2, 16 etc.\nJust keep in mind what the maximum digit is for each of these bases so you know when to carry or subtract 1 to or from the higher-order digit of the result or operand."),(0,r.yg)("p",null,"You can find a few examples of arithmetic operations in base 2 ",(0,r.yg)("a",{parentName:"p",href:"https://www.tutorialspoint.com/computer_logical_organization/binary_arithmetic.htm"},"here")),(0,r.yg)("h3",{id:"logical-operations"},"Logical Operations"),(0,r.yg)("h4",{id:"operators-on-binary-values"},"Operators on Binary Values"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"NOT Operation"),":\nInverts each bit.")),(0,r.yg)("p",null,"Example:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-text"},"INV(0b10011010) = 0b01100101\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Logical AND Operation"),":\nPerforms the 'and' operation between bits at the same positions in operands.")),(0,r.yg)("p",null,"Example:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-text"},"0b1001 AND 0b0111 = 0b0001\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Logical OR Operation"),":\nPerforms the 'or' operation between bits at the same positions in operands.")),(0,r.yg)("p",null,"Example:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-text"},"0b1001 OR 0b0111 = 0b1111\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Exclusive OR (XOR) Operation"),":")),(0,r.yg)("p",null,"If bits at the same positions in operands have equal values, the resulting bit is 0;\notherwise, it's 1."),(0,r.yg)("p",null,"Example:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-text"},"0b1001 XOR 0b0111 = 0b1110\n")),(0,r.yg)("h4",{id:"logical-shifts"},"Logical Shifts"),(0,r.yg)("p",null,"Logical shifts left/right involve moving each bit by one position.\nSince the result must be on the same number of bits as the initial value, the first bit is lost, and the empty space is filled with a 0 bit."),(0,r.yg)("p",null,(0,r.yg)("img",{alt:"Left Logical Shift",src:a(5902).A})),(0,r.yg)("p",null,(0,r.yg)("img",{alt:"Right Logical Shift",src:a(9751).A})),(0,r.yg)("p",null,"For explanations related to bitwise operations in C, refer to the guide at ",(0,r.yg)("a",{parentName:"p",href:"https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/"},"Bitwise Operators in C"),"."),(0,r.yg)("h2",{id:"hexadecimal-system"},"Hexadecimal System"),(0,r.yg)("p",null,"In the ",(0,r.yg)("strong",{parentName:"p"},"hexadecimal system")," (base 16), values are represented as a string of characters from '0' to '9' or 'a' to 'f'.\nA byte consists of two such characters, so each character corresponds to a group of 4 bits (a nibble)."),(0,r.yg)("h3",{id:"conversion-from-decimal-to-binaryhexadecimal"},"Conversion from Decimal to Binary/Hexadecimal"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Divide the number successively by the base number (2 or 16) and keep the remainders."),(0,r.yg)("li",{parentName:"ul"},"When the quotient of the division becomes 0, write down the remainders in reverse order."),(0,r.yg)("li",{parentName:"ul"},"In the case of base 16, when the remainder is greater than 9, letters a-f are used (",(0,r.yg)("inlineCode",{parentName:"li"},"0xa = 10"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"0xf = 15"),").")),(0,r.yg)("h4",{id:"example-conversion-of-the-number-0xd9b1-to-decimal"},"Example: Conversion of the number 0xD9B1 to decimal"),(0,r.yg)("p",null,"$$ \\texttt{0xD9B1} = 1 \\cdot 16 ^ 0 + 11 \\cdot 16 ^ 1 + 9 \\cdot 16 ^ 2 + 13 \\cdot 16 ^ 3 = 55729 $$"),(0,r.yg)("h3",{id:"conversion-between-binary-and-hexadecimal"},"Conversion between Binary and Hexadecimal"),(0,r.yg)("p",null,"As mentioned earlier, a digit in a hexadecimal number corresponds to a group of 4 bits (a nibble).\nTherefore, to convert a number from hexadecimal to binary, it's sufficient to transform each digit into the equivalent 4-bit group."),(0,r.yg)("h4",{id:"example-conversion-of-the-number-0xd9b1-to-binary"},"Example: Conversion of the number 0xD9B1 to binary"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"0x1 = 0b0001")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"0xB = 0b1011")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"0x9 = 0b1001")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"0xD = 0b1101"))),(0,r.yg)("p",null,"Thus, the resulting binary number is ",(0,r.yg)("inlineCode",{parentName:"p"},"0b1101100110110001"),"."),(0,r.yg)("p",null,"The reverse operation, conversion from binary to hexadecimal, can be done by converting each group of 4 bits into the corresponding digit in hexadecimal."),(0,r.yg)("h3",{id:"use-of-base-16-representation"},"Use of Base 16 Representation"),(0,r.yg)("p",null,"The hexadecimal system is used to represent memory addresses and to visualize data in a more interpretable way than a sequence composed only of 0s and 1s.\nThe image below provides an example in this regard:"),(0,r.yg)("p",null,(0,r.yg)("img",{alt:"Memory Map",src:a(2456).A,width:"845",height:"475"})),(0,r.yg)("p",null,"(Image taken from ",(0,r.yg)("a",{parentName:"p",href:"https://www.digital-detective.net/"},"Digital Detective"),")"),(0,r.yg)("h2",{id:"representation-of-data-types"},"Representation of Data Types"),(0,r.yg)("p",null,"In a computer's memory, a value is stored on a fixed number of bits.\nDepending on the architecture, each processor can access a maximum number of bits in a single operation, which represents the word size."),(0,r.yg)("p",null,"The sizes of common data types used in C are dependent on both the processor and the platform on which the program was compiled (operating system, compiler).\nThe table below presents the sizes of data types on a 32-bit architecture processor, when the program is compiled using gcc under Linux."),(0,r.yg)("p",null,"On the left side of the image ",(0,r.yg)("a",{parentName:"p",href:"#use-of-base-16-representation"},"above"),", we have memory addresses where data is located.\nAt address ",(0,r.yg)("inlineCode",{parentName:"p"},"0x0009FA08"),", the first 4 bytes starting from offset ",(0,r.yg)("inlineCode",{parentName:"p"},"0x02")," are ",(0,r.yg)("inlineCode",{parentName:"p"},"0x01")," ",(0,r.yg)("inlineCode",{parentName:"p"},"0x00"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"0xFF"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"0xFF"),".\nThese can represent a 4-byte integer, 4 characters, or 2 integers on 2 bytes.\nBy using base 16, we can interpret the data and infer what they might represent."),(0,r.yg)("p",null,"The table below shows the sizes of data types on a 32-bit processor."),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:"center"},"Data Type"),(0,r.yg)("th",{parentName:"tr",align:"center"},"Number of Bits"),(0,r.yg)("th",{parentName:"tr",align:"center"},"Number of Bytes"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"char")),(0,r.yg)("td",{parentName:"tr",align:"center"},"8"),(0,r.yg)("td",{parentName:"tr",align:"center"},"1")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"short")),(0,r.yg)("td",{parentName:"tr",align:"center"},"16"),(0,r.yg)("td",{parentName:"tr",align:"center"},"2")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"int")),(0,r.yg)("td",{parentName:"tr",align:"center"},"32"),(0,r.yg)("td",{parentName:"tr",align:"center"},"4")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"size_t")),(0,r.yg)("td",{parentName:"tr",align:"center"},"32"),(0,r.yg)("td",{parentName:"tr",align:"center"},"4")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"long")),(0,r.yg)("td",{parentName:"tr",align:"center"},"32"),(0,r.yg)("td",{parentName:"tr",align:"center"},"4")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"long long")),(0,r.yg)("td",{parentName:"tr",align:"center"},"64"),(0,r.yg)("td",{parentName:"tr",align:"center"},"8")))),(0,r.yg)("p",null,"| pointer     | 32             | 4               |"),(0,r.yg)("p",null,"On a 64-bit machine, the table above still holds true except for the types below.\nOn 64-bit processors, addresses are 64 bits wide, which obviously affects the size of pointers and ",(0,r.yg)("inlineCode",{parentName:"p"},"size_t"),"."),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:"center"},"Data Type"),(0,r.yg)("th",{parentName:"tr",align:"center"},"Number of Bits"),(0,r.yg)("th",{parentName:"tr",align:"center"},"Number of Bytes"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"size_t")),(0,r.yg)("td",{parentName:"tr",align:"center"},"64"),(0,r.yg)("td",{parentName:"tr",align:"center"},"8")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"long")),(0,r.yg)("td",{parentName:"tr",align:"center"},"64"),(0,r.yg)("td",{parentName:"tr",align:"center"},"8")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"pointer"),(0,r.yg)("td",{parentName:"tr",align:"center"},"64"),(0,r.yg)("td",{parentName:"tr",align:"center"},"8")))),(0,r.yg)("h2",{id:"order-of-representation-for-numbers-larger-than-one-byte-little-endian-vs-big-endian"},"Order of Representation for Numbers Larger than One Byte (Little-Endian vs Big-Endian)"),(0,r.yg)("p",null,"For representing values larger than one byte, there are two possible methods, both used in practice:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"Little-Endian: The least significant byte is stored first (bytes are stored in reverse order).\nThis model is used by the Intel x86 processor family.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"Big-Endian: The most significant byte is stored first."))),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example"),": We want to store the value 0x4a912480 in memory on 32 bits (4 bytes), starting at address ",(0,r.yg)("inlineCode",{parentName:"p"},"0x100"),", using both methods:"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:"center"},"Method"),(0,r.yg)("th",{parentName:"tr",align:"center"},"Address ",(0,r.yg)("inlineCode",{parentName:"th"},"0x100")),(0,r.yg)("th",{parentName:"tr",align:"center"},"Address ",(0,r.yg)("inlineCode",{parentName:"th"},"0x101")),(0,r.yg)("th",{parentName:"tr",align:"center"},"Address ",(0,r.yg)("inlineCode",{parentName:"th"},"0x102")),(0,r.yg)("th",{parentName:"tr",align:"center"},"Address ",(0,r.yg)("inlineCode",{parentName:"th"},"0x103")))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"Little-Endian"),(0,r.yg)("td",{parentName:"tr",align:"center"},"0x80"),(0,r.yg)("td",{parentName:"tr",align:"center"},"0x24"),(0,r.yg)("td",{parentName:"tr",align:"center"},"0x91"),(0,r.yg)("td",{parentName:"tr",align:"center"},"0x4a")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"Big-Endian"),(0,r.yg)("td",{parentName:"tr",align:"center"},"0x4a"),(0,r.yg)("td",{parentName:"tr",align:"center"},"0x91"),(0,r.yg)("td",{parentName:"tr",align:"center"},"0x24"),(0,r.yg)("td",{parentName:"tr",align:"center"},"0x80")))))}d.isMDXComponent=!0},2456:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/hex-view-70f8a8fe3819dd4265d1ed064899fe6b.png"},5902:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/left-logical-shift-8a7457b9b81e57808f65c343bdf0706f.svg"},9751:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/right-logical-shift-f622a1bc8014edbba4e5222fafabb919.svg"}}]);